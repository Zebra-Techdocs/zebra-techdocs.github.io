
<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Online Documentation for Zebra Technologies developer tools and utiltiescomp including EMDK for Android, EMDK for Xamarin, StageNow, Enterprise Browser.">
    <meta name="author" content="Zebra Technologies">
    <meta name="google-site-verification" content="i4B78BrWnNy8ShJwe5feRW3jO3HE6gfYlYqYbxfl8yY">
    <meta name="msvalidate.01" content="6B651B00161BCE79B8950AC09D5C4C75">
    <meta title="Enterprise Keyboard APIs">
    <title>Enterprise Keyboard APIs - Zebra Technologies TechDocs</title>
    <!-- core CSS -->
    <link href="/css/bootstrap.min.css" rel="stylesheet">
    <link href="/css/font-awesome.min.css" rel="stylesheet">
    <link href="/css/animate.min.css" rel="stylesheet">
    <link href="/css/owl.carousel.css" rel="stylesheet">
    <link href="/css/owl.transitions.css" rel="stylesheet">
    <link href="/css/prettyPhoto.css" rel="stylesheet">
    <link href="/css/main.css" rel="stylesheet">
    <link href="/css/responsive.css" rel="stylesheet">
    <link href="/css/prettify.css" rel="stylesheet">
    <link href="/css/bootstrap-treenav.min.css" rel="stylesheet">
    <!--[if lt IE 9]>
    <script src="js/html5shiv.js"></script>
    <script src="js/respond.min.js"></script>
    <![endif]--> 

    <script src="//load.sumome.com/" data-sumo-site-id="699cb66cf4dc59352efb45705526d15cbe314e1cd43f7761b94d96f3cf7338e8" async="async"></script>
    <link rel="shortcut icon" href="/favicon.ico">
<script src="/js/jquery.js"></script></head><!--/head-->


<body id="home" class="homepage" data-spy="scroll" data-offset="100" data-target="#toc">

    <header id="header">
        <nav id="main-menu" class="navbar navbar-default navbar-fixed-top" role="banner">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/"><img src="/images/logo.png" alt="logo" style="max-height:66px;float: inherit;
    padding-right: 3px;"></a> 
                    
                   
                </div>
                <div class="collapse navbar-collapse navbar-left">
                    <ul class="nav navbar-nav">
                        <li class="navbar-text pull-left"><strong>TechDocs</strong></li>
                        <p class="navbar-text">
                                            Enterprise Keyboard
                                            3.4
                        </p>

                    </ul>
                </div>
                <div class="collapse navbar-collapse navbar-right">
                    <ul class="nav navbar-nav">
                        


                        <li>
                            <a href="/enterprise-keyboard/3-4/guide/about">
                                    About
                            </a>
                        </li>
                        <li>
                            <a href="/enterprise-keyboard/3-4/guide/setup">
                                    Setup
                            </a>
                        </li>
                        <li>
                            <a href="/enterprise-keyboard/3-4/guide/settings">
                                    Customize
                            </a>
                        </li>
                        <li>
                            <a href="/enterprise-keyboard/3-4/guide/deploy">
                                    Deploy
                            </a>
                        </li>
                        <li>
                            <a href="/enterprise-keyboard/3-4/guide/apis">
                                    APIs
                            </a>
                        </li>
                        <li>
                            <a href="/ekd">
                                    EKB Designer
                            </a>
                        </li>
                        <li>
                            <a href="/enterprise-keyboard/3-4/download">
                                    <i class="fa fa-download"></i>
                            </a>
                        </li>
                        <li>
                            <a href="/enterprise-keyboard/3-4/search">
                                    <i class="fa fa-search"></i>
                            </a>
                        </li>
                        
                        <!-- <li ><a href="/products">SDKs</a></li>
                        <li ><a href="/samples">Samples</a></li>
                        <li ><a href="/guides">Guides</a></li>
                        <li ><a href="/tutorials">Tutorials</a></li>
                        <li ><a href="/apis">APIs</a></li> -->
                        <!-- <li><a href="#"><input type="text" class="st-default-search-input"></a></li> -->
                    </ul>
                </div>
            </div><!--/.container-->
        </nav><!--/nav-->
    <div class="alert alert-danger alert-dismissible fade in" role="alert">
        <button type="button" class="close" data-dismiss="alert" aria-label="Close"><span aria-hidden="true">×</span></button> 
        <h4><i class="fa fa-exclamation-circle" style="color:#FF0000;"></i> WARNING: Newer versions of this product and documentation are available. <a href="https://techdocs.zebra.com/enterprise-keyboard" class="btn btn-danger">See the latest</a></h4>
    </div>
  </header><!--/header-->
<div class="container-fluid">    <section id="blog">
        <div class="">
            <section class="content-with-sidebar">
            <div class="row">
                <div class="col-sm-12 ">

                    <div id="mainContent" class="row">
                        <div class="col-sm-12">
                            <div class="blog-post blog-large wow fadeInLeft" data-wow-duration="300ms" data-wow-delay="0ms">
                            <!-- Start of guide -->
                                <div class="service-box wow fadeInRight">
                                    <div class="">

<!--                         <p><h2 id="overview">Overview</h2>

<p>Zebra Enterprise Keyboard APIs operate primarily through Android intents&ndash;specific commands that can be used by Android applications to control EKB and layouts made with the <a href="/ekd">Enterprise Keyboard Designer</a> (EKB Designer, or EKD), Zebra's Windows-based custom keyboard creator tool. This guide describes the functionality of the intents supported by EKB and their effects on EKD layouts.</p>

<h3 id="requirements">Requirements</h3>

<p>Using EKB APIs requires experience with Java programming, familiarity with Android intents and at least one custom layout file (i.e. <code>myLayout.encrypted</code>). It also requires knowledge of EKB usage, features and terminology. Learn more <a href="http://techdocs.zebra.com/enterprise-keyboard">about Enterprise Keyboard</a>.</p>

<h3 id="abouttheapis">About the APIs</h3>

<p>Enterprise Keyboard APIs allow the following functions: </p>

<ul>
<li><strong>ENABLE</strong> (true/false) enables or disables the Enterprise Keyboard </li>

<li><strong>GET</strong> can return lists of: 


<ul>
<li>Available key layouts made with EKD</li>

<li>Current key layout group (file name) and the name of the current key layout</li></ul>
</li>

<li><strong>SET</strong> switches to the specified keyboard or key layout</li>

<li><strong>SHOW</strong> displays the specified layout on the device</li>

<li><strong>RESET</strong> Resets all key layouts and enables Enterprise Keyboard (if disabled)</li>
</ul>

<blockquote>
  <ul>
  <li><strong>Zebra recommends resetting to the default input device when quitting an app that uses EKB</strong>. </li>
  </ul>
</blockquote>

<h3 id="alsosee">Also See</h3>

<ul>
<li><a href="https://developer.zebra.com/blog/dynamically-switching-keyboards-zebra-android-devices">Dynamically Switching Keyboards</a> | Implementation details and sample code by Zebra engineering</li>

<li><a href="https://developer.zebra.com/blog/exploring-enterprise-keyboard-api">Exploring the Enterprise Keyboard API</a> | Working with EKD-made Custom Layouts by Zebra engineering</li>
</ul>

<hr />

<h3 id="importantpleaseread"><code>IMPORTANT - PLEASE READ</code></h3>

<ul>
<li><strong><u>Only one keyboard or custom key layout can be displayed on the device screen at a time</u></strong>. When a custom key layout is displayed, all other keyboards are hidden, including the standard Enterprise Keyboard alpha-numeric layout. </li>

<li><strong>Layouts made with EKD must be called by an app using intents</strong> to be displayed.</li>

<li><strong>Apps on the device can access <u>only a single EKD project file</u></strong>, but multiple layouts can be saved in that single project file and called independently through intents.  </li>

<li>EKD projects are saved and deployed as encrypted files that can be decrypted on the device only by <strong>DataWedge, Enterprise Browser and Enterprise Keyboard</strong> and applications running on a Zebra Android device. </li>

<li>Layout files can be imported into Enterprise Keyboard Designer and modified or supplemented with additional keys and/or layouts. </li>

<li><strong>Zebra recommends resetting to the default input device when quitting an app that uses EKB</strong>. </li>

<li>In this guide, the terms “button” and “key” are used interchangeably. </li>

<li><strong>If an app contains logic to show the keyboard automatically</strong> when an activity comes to the foreground (i.e. the activity has a declared flag of <code>android:windowSoftInputMode</code>=<code>stateVisible</code> in its <code>AndroidManifest.xml</code> file), <strong>that app cannot hide the keyboard using the SHOW API</strong>.</li>

<li>Apps running in full screen mode display custom key layouts with an extra margin from the bottom of the device screen.</li>

<li><strong>When using DataWedge to switch layouts</strong>, the EKB fixed layout is sometimes shown briefly or until the focus changes again. </li>

<li><strong>When custom layouts are displayed, <u>all EKB settings, preferences and functions are suspended</u></strong>.</li>
</ul>

<hr />

<h2 id="appwindowresizing">App Window Resizing</h2>

<p>Android apps generally adjust window size when a general-purpose keyboard is displayed. Window resizing for EKD custom key layouts are subject to the rules below.   </p>

<h4 id="ekdwindowresizingbehavior">EKD Window Resizing Behavior</h4>

<ul>
<li><strong>An application activity's main window is resized <u>only if the width of the custom key layout is greater than or equal to 50 percent of device's screen width</u></strong>.</li>

<li>An activity's main <strong>window will NOT be resized if a custom key layout is positioned on top of the app's title bar or toolbar</strong> (sometimes known as the "Action" bar). </li>

<li>In some cases, window resizing results in a blank portion of the screen. </li>

<li><strong>To disable windows resizing of an activity’s main window</strong>, set the following attribute in the app's activity manifest file: 


<ul>
<li><code>android:windowSoftInputMode=”adjustNothing”</code></li></ul>
</li>
</ul>

<hr />

<!-- 11/13/19- removed per eng. b/c it applies to "EKB test app"

### Using EKB APIs
The following example describes a company with business requirements that call for an application with four main activities and corresponding GUI screens: 

* `FunctionKeyActivity`
* `DisableActivity`
* `MultiInputActivity`
* `ResetActivity` 

`FunctionKeyActivity` is the launcher activity of the application, and is the first activity in the following sequence of the activities:

`FunctionKeyActivity` -> `DisableActivity` -> `MultiInputActivity` -> `ResetActivity`

Each activity involves the following keyboard requirements:

When `FunctionKeyActivity` comes to the foreground, the app should `GET` the following information:
* Available layouts in the device
* Current layout group name
* Current layout name

* `FunctionKeyActivity` should then set a function-key layout to show immediately when the app it comes in the foreground.
* `DisableActivity` does not use a keyboard, so keyboard should be disabled when this activity comes to the foreground. If the device user taps on an input area, a keyboard should not appear.
* `MultiInputActivity` has two input areas. When the device user taps on the first input area, a qwerty keyboard layout appears. When the user taps on the second input area, the numeric key layout appears.
* `ResetActivity` uses a regular keyboard, so keyboard should be reset.

10/30/19- removed until the app location is known 
> **Note**: Zebra provides a sample Android app that implements the functions described above.
 -->

<hr>

<h2 id="intents" class="anchor"><a class="heading-anchor" href="#intents"><span></span></a>Intents</h2>

<p>App developers and administrators can use Android intents to determine programmatically which layouts are available in a device and to select and switch between layouts according to the input requirements of an application.</p>

<h3 id="sendingintents" class="anchor"><a class="heading-anchor" href="#sendingintents"><span></span></a>Sending Intents</h3>

<p>The syntax defined in Enterprise Keyboard 2.0 (and higher) permits multiple Enterprise Keyboard API calls as extras on a single intent action. The syntax is as follows:</p>

<pre class="prettyprint"><code>
Intent intent = new Intent();
intent.setAction("com.symbol.ekb.api.ACTION_GET");
intent.setPackage("com.symbol.mxmf.csp.enterprisekeyboard");
intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
String[]propertiesToRetrieve = {"AVAILABLE_LAYOUTS"};
intent.putExtra("PROPERTIES_TO_GET", propertiesToRetrieve);
</code></pre>

<h3 id="receivingresults" class="anchor"><a class="heading-anchor" href="#receivingresults"><span></span></a>Receiving Results</h3>

<p>For intents that query EKB for information (such as <code>GET_AVAILABLE_LAYOUTS</code>), the app must declare a receiver in the <code>AndroidManifest.xml</code> file and add a pending intent in the query intent as an extra to receive the result. </p>

<h5 id="registerthebroadcastreceivertoreceivetheresults" class="anchor"><a class="heading-anchor" href="#registerthebroadcastreceivertoreceivetheresults"><span></span></a>Register the broadcast receiver to receive the results:</h5>

<pre class="prettyprint"><code>
//Declare broadcast receiver in AndroidManifest.xml file
&lt;receiver android:name=".MyBroadcastReceiver"&gt;&lt;/receiver&gt;

//Sending intent to get available layouts

Intent intent = new Intent();
intent.setAction("com.symbol.ekb.api.ACTION_GET");
intent.setPackage("com.symbol.mxmf.csp.enterprisekeyboard");
intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
String[] propertiesToRetrieve = {"AVAILABLE_LAYOUTS"};
intent.putExtra("PROPERTIES_TO_GET", propertiesToRetrieve);


//Intent sent back with status (via explicit broadcast)

Intent responseIntent = new Intent(this, MyBroadcastReceiver.class);
PendingIntent piResponse = PendingIntent.getBroadcast(getApplicationContext(), requestCode, responseIntent, flags);
intent.putExtra("CALLBACK_RESPONSE", piResponse);
sendBroadcast(intent);

//Receiving the result
@Override
public void onReceive(Context context, Intent intent) {
    Toast.makeText(context, "onReceived", Toast.LENGTH_SHORT).show();
    Bundle mBundle = intent.getExtras();
    String result = mBundle.getString(“RESULT_CODE”);
    String msg = mBundle.getString(“RESULT_MESSAGE”);
}
</code></pre>

<hr>

<h2 id="layoutswitching" class="anchor"><a class="heading-anchor" href="#layoutswitching"><span></span></a>Layout Switching</h2>

<p>This section explains the program logic involved with switching layouts with Android intents when focus of an input field changes. </p>

<blockquote>
  <p><strong>Note</strong>: Layouts also can be controlled through DataWedge. <a href="/datawedge/latest/guide/utilities/ekb/">Find out how</a>. </p>
</blockquote>

<h3 id="requirements-1" class="anchor"><a class="heading-anchor" href="#requirements-1"><span></span></a>Requirements</h3>

<ul>
<li><strong>EKB v3.2 installed and activated on the target device(s)</strong> and set as the default input source</li>

<li><strong>A <em><u>single</u></em> EKD layout file</strong> (i.e. <code>myProject.encrypted</code>) in the following device folder: <br>
<code>/enterprise/device/settings/ekb/config/</code></li>

<li><strong>Layout file must contain ALL layouts</strong> being used by apps on the device</li>
</ul>

<blockquote>
  <p>See the <a href="/ekd">Enterprise Keyboard Designer Guide</a> for help creating a layout file. </p>
</blockquote>

<hr>

<h3 id="usecase1" class="anchor"><a class="heading-anchor" href="#usecase1"><span></span></a>Use Case 1</h3>

<p>This case describes an Android app with two text input fields. Substitute sample names shown below with those in the deployed <a href="../deploy">layout definition file</a>. </p>

<ul>
<li><code>editText1</code> input field uses the standard Enterprise Keyboard fixed layout, which includes numeric, alpha-numeric, scan and symbol keyboards manually switchable by the user as needed.  </li>

<li><code>editText2</code> input field uses a custom layout made with EKD that contains keys specifically designed for a particular type of input. </li>
</ul>

<p><strong>Program logic for switching between standard and custom layouts</strong> according to changes from <code>onFocus</code> listener: </p>

<h4 id="whentheedittext1fieldgetsfocussendthefollowingintentstodisplaytheekbfixedlayout" class="anchor"><a class="heading-anchor" href="#whentheedittext1fieldgetsfocussendthefollowingintentstodisplaytheekbfixedlayout"><span></span></a>When the <code>editText1</code> field gets focus, send the following intents to display the EKB fixed layout:</h4>

<ol>
<li>Send <code>ENABLE</code> intent to Enterprise Keyboard fixed layout.</li>

<li>Send <code>RESET</code> to the custom EKB layout.</li>

<li>When the <code>onReceive()</code> method receives a result type value of <code>DEFAULT_LAYOUT</code>, <strong>send a</strong> <code>SHOW</code> <strong>intent to the EKB fixed layout</strong> to display it. </li>
</ol>

<h4 id="whenthefocuschangestoedittext2sendthefollowingintentstoshowthecustomlayout" class="anchor"><a class="heading-anchor" href="#whenthefocuschangestoedittext2sendthefollowingintentstoshowthecustomlayout"><span></span></a>When the focus changes to <code>edittext2</code>, send the following intents to show the custom layout:</h4>

<ol>
<li>Send a <code>SET</code> intent to set the custom layout.<br>
<strong>Note</strong>: If the custom layout name is not known, send a <code>GET</code> intent <u><strong><em>before</em></strong> the calling the onFocus change listener</u> to receive a list of all available layout names in the layout file. Then send the <code>SET</code> intent with the name of the desired layout. </li>

<li>On <code>focusOut</code> of <code>editText1</code>, send <code>ENABLE</code> "false" intent the EKB fixed layout to disable it.</li>
</ol>

<blockquote>
  <p><strong><code>IMPORTANT:</code> Enterprise Keyboard must be enabled if the application goes to the background</strong> to avoid a device user resetting the layout from outside the app.</p>
</blockquote>

<hr>

<h3 id="usecase2" class="anchor"><a class="heading-anchor" href="#usecase2"><span></span></a>Use Case 2</h3>

<p>This case describes an Android app with two text input fields, both requiring custom layouts alternated within a specific time interval: </p>

<ul>
<li><code>editText1</code> input field uses a custom layout called <code>numericLayout.encrypted</code>  </li>

<li><code>editText2</code> input field uses a custom layout called <code>functionLayout.encrypted</code></li>
</ul>

<p><strong>Program logic for switching between two custom layouts</strong> according to changes from <code>onFocus</code> listener: </p>

<h4 id="whentheedittext1fieldgetsfocussendthefollowingintentstodisplaynumericlayout" class="anchor"><a class="heading-anchor" href="#whentheedittext1fieldgetsfocussendthefollowingintentstodisplaynumericlayout"><span></span></a>When the <code>editText1</code> field gets focus, send the following intents to display <code>numericLayout</code>:</h4>

<ol>
<li>Send a <code>SET</code> intent for <code>numericLayout.encrypted</code> to set the custom numeric layout.<br>
<strong>Note</strong>: If the custom layout name is not known, send a <code>GET</code> intent <u><strong><em>before</em></strong> the calling the onFocus change listener</u> to receive a list of all available layout names in the layout file. Then send the <code>SET</code> intent with the name of the desired layout. </li>
</ol>

<h4 id="whenthefocuschangestoedittext2sendthefollowingintentstoshowthecustomlayout-1" class="anchor"><a class="heading-anchor" href="#whenthefocuschangestoedittext2sendthefollowingintentstoshowthecustomlayout-1"><span></span></a>When the focus changes to <code>edittext2</code>, send the following intents to show the custom layout:</h4>

<ol>
<li>Send a <code>SET</code> intent for <code>functionLayout.encrypted</code> to set the custom function-key layout.<br>
<strong>Note</strong>: If the custom layout name is not known, send a <code>GET</code> intent <u><strong><em>before</em></strong> the calling the onFocus change listener</u> to receive a list of all available layout names in the layout file. Then send the <code>SET</code> intent with the name of the desired layout. </li>
</ol>

<blockquote>
  <p><strong><code>IMPORTANT:</code> Enterprise Keyboard must be enabled if the application goes to the background</strong> to avoid a device user resetting the layout from outside the app.</p>
</blockquote>

<hr>

<h2 id="apiparameterssamples" class="anchor"><a class="heading-anchor" href="#apiparameterssamples"><span></span></a>API Parameters, Samples</h2>

<h3 id="enable" class="anchor"><a class="heading-anchor" href="#enable"><span></span></a>ENABLE</h3>

<p><strong>Used to enable or disable the Enterprise Keyboard</strong>. </p>

<p><strong>Parameter values</strong>:</p>

<ul>
<li><strong>TRUE</strong>: Enterprise Keyboard enabled and shown whenever device user taps on an input field.</li>

<li><strong>FALSE</strong>: Enterprise Keyboard is disabled and does not show even after using SHOW API or tapping on an input area.</li>
</ul>

<p>Once Enterprise Keyboard is enabled/disabled, the requested application receives a response intent containing a <code>RESULT_CODE</code> and <code>RESULT_MESSAGE</code> extras.</p>

<h5 id="showkeyboard" class="anchor"><a class="heading-anchor" href="#showkeyboard"><span></span></a>Show keyboard:</h5>

<pre class="prettyprint"><code>
        Intent intent = new Intent();
    intent.setAction("com.symbol.ekb.api.ACTION_UPDATE");
        intent.setPackage("com.symbol.mxmf.csp.enterprisekeyboard");
    intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);

// needToEnable is a Boolean object; it can be true or false:

    intent.putExtra("ENABLE", needToEnable);    

//  Intent sent back with status (via explicit broadcast)

Intent responseIntent = new Intent(this, MyBroadcastReceiver.class);
PendingIntent piResponse = PendingIntent.getBroadcast(getApplicationContext(), requestCode, responseIntent, flags);
intent.putExtra("CALLBACK_RESPONSE", piResponse);
sendBroadcast(intent);
</code></pre>

<h5 id="receivetheresult" class="anchor"><a class="heading-anchor" href="#receivetheresult"><span></span></a>Receive the result:</h5>

<pre class="prettyprint"><code>::java
    @Override
public void onReceive(Context context, Intent intent) {
    Toast.makeText(context, "onReceived", Toast.LENGTH_SHORT).show();
    Bundle mBundle = intent.getExtras();
    String result = mBundle.getString("RESULT_CODE");
    String msg = mBundle.getString("RESULT_MESSAGE");    
}
</code></pre>

<hr>

<h3 id="getavailablelayouts" class="anchor"><a class="heading-anchor" href="#getavailablelayouts"><span></span></a>GET (available layouts)</h3>

<p><strong>Returns a list of custom key layouts</strong> currently available in the device.</p>

<h5 id="getavailablekeylayouts" class="anchor"><a class="heading-anchor" href="#getavailablekeylayouts"><span></span></a>Get available key layouts:</h5>

<pre class="prettyprint"><code>
    Intent intent = new Intent();
intent.setAction("com.symbol.ekb.api.ACTION_GET");
    intent.setPackage("com.symbol.mxmf.csp.enterprisekeyboard");
intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
String[] propertiesToRetrieve = {"AVAILABLE_LAYOUTS"};
intent.putExtra("PROPERTIES_TO_GET", propertiesToRetrieve);

// Intent is sent back with status (via explicit broadcast)

Intent responseIntent = new Intent(this, MyBroadcastReceiver.class);
PendingIntent piResponse = PendingIntent.getBroadcast(getApplicationContext(), requestCode, responseIntent, flags);
intent.putExtra("CALLBACK_RESPONSE", piResponse);
sendBroadcast(intent);
</code></pre>

<h5 id="receivetheresult-1" class="anchor"><a class="heading-anchor" href="#receivetheresult-1"><span></span></a>Receive the result:</h5>

<pre class="prettyprint"><code>
    @Override
public void onReceive(Context context, Intent intent) {
    Toast.makeText(context, "onReceived", Toast.LENGTH_SHORT).show();
    Bundle mBundle = intent.getExtras();
    String result = mBundle.getString("RESULT_CODE");
    String msg = mBundle.getString("RESULT_MESSAGE");

    if(mBundle.get("AVAILABLE_LAYOUTS") != null) {
        Object[] respObj = (Object[]) mBundle.getParcelableArray("AVAILABLE_LAYOUTS");
        for(int i = 0; i &lt; respObj.length; i++) {
            Bundle temp = (Bundle) respObj[i];
            String layoutGroupName = temp.getString("LAYOUT_GROUP");
            Object[] layoutNamesBundle = (Object[]) temp.get("LAYOUTS");
            for(int j = 0; j &lt;layoutNamesBundle.length; j++) {
                Bundle tempBundle = (Bundle) layoutNamesBundle[j];
                String layoutName = tempBundle.getString("LAYOUT_NAME");
            }
        }
    }
}
</code></pre>

<hr>

<h3 id="getcurrentlayout" class="anchor"><a class="heading-anchor" href="#getcurrentlayout"><span></span></a>GET (current layout)</h3>

<p><strong>Returns the current key layout group and the current key layout name</strong>. If Enterprise Keyboard is the current keyboard, returns the currently selected EKB layout.</p>

<h5 id="getcurrentkeylayoutgroupandlayoutname" class="anchor"><a class="heading-anchor" href="#getcurrentkeylayoutgroupandlayoutname"><span></span></a>Get current key layout group and layout name:</h5>

<pre class="prettyprint"><code>
    Intent intent = new Intent();
intent.setAction("com.symbol.ekb.api.ACTION_GET");
    intent.setPackage("com.symbol.mxmf.csp.enterprisekeyboard");
intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
String[] propertiesToRetrieve = {"CURRENT_LAYOUT_GROUP”,"CURRENT_LAYOUT_NAME"};
intent.putExtra("PROPERTIES_TO_GET", propertiesToRetrieve);

//  Intent is sent back with status (via explicit broadcast)

Intent responseIntent = new Intent(this, MyBroadcastReceiver.class);
PendingIntent piResponse = PendingIntent.getBroadcast(getApplicationContext(), requestCode, responseIntent, flags);
intent.putExtra("CALLBACK_RESPONSE", piResponse);
sendBroadcast(intent);
</code></pre>

<h5 id="receivetheresult-2" class="anchor"><a class="heading-anchor" href="#receivetheresult-2"><span></span></a>Receive the result:</h5>

<pre class="prettyprint"><code>
    @Override
public void onReceive(Context context, Intent intent) {
    Toast.makeText(context, "onReceived", Toast.LENGTH_SHORT).show();
    Bundle mBundle = intent.getExtras();
    String result = mBundle.getString("RESULT_CODE");
    String msg = mBundle.getString("RESULT_MESSAGE");
    if(mBundle.get("CURRENT_LAYOUT_GROUP") != null) {
        String currLayoutGroup = (String) mBundle.get("CURRENT_LAYOUT_GROUP");
    }
    if(mBundle.get("CURRENT_LAYOUT_NAME") != null) {
        String currLayoutName = (String) mBundle.get("CURRENT_LAYOUT_NAME");
    }
}
</code></pre>

<hr>

<h3 id="setkeylayout" class="anchor"><a class="heading-anchor" href="#setkeylayout"><span></span></a>SET (key layout)</h3>

<p><strong>Sets the custom layout in Enterprise Keyboard</strong>. While sending the intent to set the key layout, developer must add <code>CURRENT_LAYOUT_GROUP</code> and <code>CURRENT_LAYOUT_NAME</code> parameters as extras.</p>

<p>Once key layout is set in Enterprise Keyboard, requested application receives a response intent containing  <code>RESULT_CODE</code> and <code>RESULT_MESSAGE</code> extras.</p>

<h5 id="setkeylayout-1" class="anchor"><a class="heading-anchor" href="#setkeylayout-1"><span></span></a>Set key layout:</h5>

<pre class="prettyprint"><code>
    Intent intent = new Intent();
intent.setAction("com.symbol.ekb.api.ACTION_UPDATE");
    intent.setPackage("com.symbol.mxmf.csp.enterprisekeyboard");
intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
String layoutGroupName = layoutGroup.getText().toString();
String layout = layoutName.getText().toString();
intent.putExtra("CURRENT_LAYOUT_GROUP", layoutGroupName);
intent.putExtra("CURRENT_LAYOUT_NAME", layout);

// Intent is sent back with status (via explicit broadcast)

Intent responseIntent = new Intent(this, MyBroadcastReceiver.class);
PendingIntent piResponse = PendingIntent.getBroadcast(getApplicationContext(), requestCode, responseIntent, flags);
intent.putExtra("CALLBACK_RESPONSE", piResponse);
sendBroadcast(intent);
</code></pre>

<h5 id="receivetheresult-3" class="anchor"><a class="heading-anchor" href="#receivetheresult-3"><span></span></a>Receive the result:</h5>

<pre class="prettyprint"><code>
    @Override
public void onReceive(Context context, Intent intent) {
    Toast.makeText(context, "onReceived", Toast.LENGTH_SHORT).show();
    Bundle mBundle = intent.getExtras();
    String result = mBundle.getString("RESULT_CODE");
    String msg = mBundle.getString("RESULT_MESSAGE");    
    }

}
</code></pre>

<hr>

<h3 id="show" class="anchor"><a class="heading-anchor" href="#show"><span></span></a>SHOW</h3>

<p><strong>Used to show or hide the specified key layout</strong>. </p>

<p><strong><code>IMPORTANT:</code> An app CANNOT hide the keyboard using the SHOW API if the app contains logic to show the keyboard automatically when an activity comes to the foreground</strong> (i.e. the activity has a declared flag of <code>android:windowSoftInputMode</code>=<code>stateVisible</code> in its <code>AndroidManifest.xml</code> file).</p>

<p><strong>Parameter values</strong>:</p>

<ul>
<li><p><strong>TRUE</strong>: Keyboard is shown when activity is launched, even if the activity does not require input.</p></li>

<li><p><strong>FALSE</strong>: Keyboard is not shown when activity is launched; shown only when the device user taps on an input field.</p></li>
</ul>

<p>Once key layout is shown/hidden, requested application receives a response intent with RESULT_CODE and RESULT_MESSAGE.</p>

<h5 id="samplecodetoshowkeylayout" class="anchor"><a class="heading-anchor" href="#samplecodetoshowkeylayout"><span></span></a>Sample code to show key layout:</h5>

<pre class="prettyprint"><code>
Intent intent = new Intent();
intent.setAction("com.symbol.ekb.api.ACTION_UPDATE");
intent.setPackage("com.symbol.mxmf.csp.enterprisekeyboard");
intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);

// needToShow is a Boolean object; it can be true or false:

intent.putExtra("SHOW", needToShow);&nbsp;

//&nbsp; Intent is sent back with status (via explicit broadcast)

Intent responseIntent = new Intent(this, MyBroadcastReceiver.class);
PendingIntent piResponse = PendingIntent.getBroadcast(getApplicationContext(), requestCode, responseIntent, flags);
intent.putExtra("CALLBACK_RESPONSE", piResponse);
sendBroadcast(intent);
</code></pre>

<h5 id="receivetheresult-4" class="anchor"><a class="heading-anchor" href="#receivetheresult-4"><span></span></a>Receive the result:</h5>

<pre class="prettyprint"><code>
@Override
public void onReceive(Context context, Intent intent) { &nbsp;&nbsp;&nbsp; Toast._makeText_(context, *"onReceived"*, Toast.*_LENGTH_SHORT_*).show(); &nbsp;&nbsp;&nbsp; Bundle mBundle = intent.getExtras(); &nbsp;&nbsp;&nbsp; String result = mBundle.getString(*"RESULT_CODE"*); &nbsp;&nbsp;&nbsp; String msg = mBundle.getString(*"RESULT_MESSAGE"*);

}
</code></pre>

<hr>

<!-- 10/30/19- Added to ticket on 10/22/19 by eng w/no instructions; used for SHOW params and code. Other APIs might contain duplicate info; waiting for clarification.

### ENABLE

Used to enable or disable the keyboard. This param has two states:

TRUE: Keyboard is enabled but not shown unless the device user taps on an input area or SHOW API is called.
FALSE: Keyboard is disabled and does not show even after using SHOW API or tapping on an input area.
 

Once keyboard is enabled/disabled, requested application will receive a response intent having RESULT_CODE and RESULT_MESSAGE.

Sample code to show keyboard:

Intent intent = new Intent();
intent.setAction("com.symbol.ekb.api.ACTION_UPDATE");

intent.setPackage("com.symbol.mxmf.csp.enterprisekeyboard");
intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
intent.putExtra("ENABLE", needToEnable); // needToEnable is a Boolean object so it can be

                                     //either true or false.

//  Intent which will be sent back with status (via explicit broadcast)
Intent responseIntent = new Intent(this, MyBroadcastReceiver.class);
PendingIntent piResponse = PendingIntent.getBroadcast(getApplicationContext(), requestCode, responseIntent, flags);
intent.putExtra("CALLBACK_RESPONSE", piResponse);
sendBroadcast(intent);

 ** 

Sample code to receive the result:

@Override
public void onReceive(Context context, Intent intent)

{     Toast._makeText_(context, *"onReceived"*, Toast.*_LENGTH_SHORT_*).show();     Bundle mBundle = intent.getExtras();     String result = mBundle.getString(*"RESULT_CODE"*);     String msg = mBundle.getString(*"RESULT_MESSAGE"*);    }

-----
 
# RESET

Resets the Enterprise Keyboard layouts and enables the keyboard if it is disabled. After reset, user will be shown fixed layout Enterprise Keyboard.

It has two states:
# TRUE: Keyboard is reset.
# FALSE: Keyboard is not reset.

Requested application receives a response intent with RESULT_CODE and RESULT_MESSAGE.

Sample code to show keyboard:

Intent intent = new Intent();
intent.setAction("com.symbol.ekb.api.ACTION_DO");

intent.setPackage("com.symbol.mxmf.csp.enterprisekeyboard");
intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
intent.putExtra("RESET_LAYOUT", needToReset);    // needToReset is a Boolean object so it

                                             // can be either true or false.

//Intent sent back with status (via explicit broadcast)
Intent responseIntent = new Intent(this, MyBroadcastReceiver.class);
PendingIntent piResponse = PendingIntent.getBroadcast(getApplicationContext(), requestCode, responseIntent, flags);
intent.putExtra("CALLBACK_RESPONSE", piResponse);
sendBroadcast(intent);

Sample code to receive the result:

@Override
public void onReceive(Context context, Intent intent) {     Toast._makeText_(context, *"onReceived"*, Toast.*_LENGTH_SHORT_*).show();     Bundle mBundle = intent.getExtras();     String result = mBundle.getString(*"RESULT_CODE"*);     String msg = mBundle.getString(*"RESULT_MESSAGE"*);    }

-->

<hr>

<h3 id="reset" class="anchor"><a class="heading-anchor" href="#reset"><span></span></a>RESET</h3>

<p><strong>Resets the Enterprise Keyboard layouts and enables the Enterprise Keyboard (if disabled)</strong>. After reset, the fixed-layout Enterprise Keyboard is shown when an input field gets focus. </p>

<p><strong>Parameter values</strong>:</p>

<ul>
<li><strong>TRUE</strong>: Keyboard is reset</li>

<li><strong>FALSE</strong>: Keyboard is not reset</li>
</ul>

<p>The requested application receives a response intent containing RESULT_CODE and RESULT_MESSAGE extras.</p>

<h5 id="showkeyboard-1" class="anchor"><a class="heading-anchor" href="#showkeyboard-1"><span></span></a>Show keyboard:</h5>

<pre class="prettyprint"><code>
    Intent intent = new Intent();
intent.setAction("com.symbol.ekb.api.ACTION_DO");
    intent.setPackage("com.symbol.mxmf.csp.enterprisekeyboard");
intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
intent.putExtra("RESET_LAYOUT", needToReset);

                        // needToReset is a Boolean object; can be either true or false:

//Intent sent back with status (via explicit broadcast)
Intent responseIntent = new Intent(this, MyBroadcastReceiver.class);
PendingIntent piResponse = PendingIntent.getBroadcast(getApplicationContext(), requestCode, responseIntent, flags);
intent.putExtra("CALLBACK_RESPONSE", piResponse);
sendBroadcast(intent);
</code></pre>

<h5 id="receivetheresult-5" class="anchor"><a class="heading-anchor" href="#receivetheresult-5"><span></span></a>Receive the result:</h5>

<pre class="prettyprint"><code>
    @Override
public void onReceive(Context context, Intent intent) {
    Toast.makeText(context, "onReceived", Toast.LENGTH_SHORT).show();
    Bundle mBundle = intent.getExtras();
    String result = mBundle.getString("RESULT_CODE");
    String msg = mBundle.getString("RESULT_MESSAGE");    
}
</code></pre>

<hr><p></p>
 --&gt;                        

<h2 id="redirecting-to-techdocs-archive-site" class="anchor"><a class="heading-anchor" href="#redirecting-to-techdocs-archive-site"><span></span></a>Redirecting to TechDocs archive site...</h2> 


                                    </div>
                                </div>

                            </div>
                        </div>
                    </div>
                </div><!--/.col-sm-6-->
            </div>
            </section>
        </div>
    </section>    


<div class="modal fade" id="basicModal" tabindex="-1" role="dialog" aria-labelledby="basicModal" aria-hidden="true" data-backdrop="true">
			<div class="modal-dialog">
				<div class="modal-content">
					<div class="modal-header">
						<button type="button" class="close" data-dismiss="modal" aria-hidden="true">X</button>
					</div>
					<div class="modal-body">
						<div id="modalImg">
						
						</div>
					</div>
			</div>
		  </div>
		</div>
    <script>

    var new_domain = "zebra-techdocs-archive.netlify.app";
    var old_domain = window.location.host;
    var current_href = window.location.href;
    var new_href = current_href.replace(old_domain,new_domain);
    window.location = new_href;

    </script>
                                        
</div></body></html>