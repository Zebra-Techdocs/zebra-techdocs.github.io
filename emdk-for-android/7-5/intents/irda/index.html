
<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="-1">
    <meta http-equiv="CACHE-CONTROL" content="NO-CACHE">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Online Documentation for Zebra Technologies developer tools and utilties, including EMDK for Android, EMDK for Xamarin, StageNow and Enterprise Browser.">
    <meta name="author" content="Zebra Technologies">
    <meta name="google-site-verification" content="i4B78BrWnNy8ShJwe5feRW3jO3HE6gfYlYqYbxfl8yY">
    <meta name="msvalidate.01" content="6B651B00161BCE79B8950AC09D5C4C75">
    <meta title="IrDA Intents APIs">
    <title>IrDA Intents APIs - TechDocs</title>
    <!-- core CSS -->
    <link href="/css/bootstrap.min.css" rel="stylesheet">
<!--     
    <link href="/css/font-awesome.min.css" rel="stylesheet">
 -->    
    <link href="/css/all.css" rel="stylesheet">
    <link href="/css/v4-shims.css" rel="stylesheet">
    <link href="/css/animate.min.css" rel="stylesheet">
    <link href="/css/owl.carousel.css" rel="stylesheet">
    <link href="/css/owl.transitions.css" rel="stylesheet">
    <link href="/css/prettyPhoto.css" rel="stylesheet">
    <link href="/css/main.css" rel="stylesheet">
    <link href="/css/responsive.css" rel="stylesheet">
    <link href="/css/prettify.css" rel="stylesheet">
    <link href="/css/bootstrap-treenav.min.css" rel="stylesheet">
    <!--[if lt IE 9]>
    <script src="js/html5shiv.js"></script>
    <script src="js/respond.min.js"></script>
    <![endif]--> 

    <script src="//load.sumome.com/" data-sumo-site-id="699cb66cf4dc59352efb45705526d15cbe314e1cd43f7761b94d96f3cf7338e8" async="async"></script>
    <link rel="shortcut icon" href="/favicon.ico">
<script src="/js/jquery.js"></script></head><!--/head-->


<body id="home" class="homepage" data-spy="scroll" data-offset="100" data-target="#toc">

    <header id="header">
        <nav id="main-menu" class="navbar navbar-default navbar-fixed-top" role="banner">
            <div class="container-fluid">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="/"><img src="/images/logo.png" alt="logo" style="max-height:66px;float: inherit;
    padding-right: 3px;"></a> 
                    
                   
                </div>
                <div class="collapse navbar-collapse navbar-left">
                    <ul class="nav navbar-nav">
                        <li class="navbar-text pull-left"><strong>TechDocs</strong></li>
                        <li class="dropdown">
                          <button class="btn btn-default dropdown-toggle" type="button" data-toggle="dropdown"> EMDK For Android 7.5
                          <span class="caret"></span></button>
                          <ul class="dropdown-menu">
                                <li><a onclick="changeVersion('5-0','4-2','/emdk-for-android/4-2/guide/about')">EMDK For Android 4.2</a></li>
                                <li><a onclick="changeVersion('5-0','4-0','/emdk-for-android/4-0/guide/about')">EMDK For Android 4.0</a></li>
                          </ul>
                        </li>                    
                    </ul>
                </div>
                <div class="collapse navbar-collapse navbar-right">
                    <ul class="nav navbar-nav">
                        


                        <li>
                            <a href="/emdk-for-android/7-5/guide/about">
                                    About
                            </a>
                        </li>
                        <li>
                            <a href="/emdk-for-android/7-5/guide/gettingstarted">
                                    Get Started
                            </a>
                        </li>
                        <li>
                            <a href="/emdk-for-android/7-5/tutorial/">
                                    Tutorials
                            </a>
                        </li>
                        <li>
                            <a href="/emdk-for-android/7-5/samples">
                                    Samples
                            </a>
                        </li>
                        <li>
                            <a href="/emdk-for-android/7-5/guide/programming-guides">
                                    Guides
                            </a>
                        </li>
                        <li>
                            <a href="/emdk-for-android/7-5/guide/profile-manager-guides">
                                    Profile Manager
                            </a>
                        </li>
                        <li>
                            <a href="/emdk-for-android/7-5/faq">
                                    FAQs
                            </a>
                        </li>
                        <li>
                            <a href="/emdk-for-android/7-5/apimenu">
                                    APIs
                            </a>
                        </li>
                        <li>
                            <a href="https://developer.zebra.com/forum/search?keys=&amp;field_zebra_curated_tags_tid%5B%5D=184">
                                    <i class="fa fa-comments-o"></i>
                            </a>
                        </li>
                        <li>
                            <a href="/emdk-for-android/7-5/search">
                                    <i class="fa fa-search"></i>
                            </a>
                        </li>
                        
                        <!-- <li ><a href="/products">SDKs</a></li>
                        <li ><a href="/samples">Samples</a></li>
                        <li ><a href="/guides">Guides</a></li>
                        <li ><a href="/tutorials">Tutorials</a></li>
                        <li ><a href="/apis">APIs</a></li> -->
                        <!-- <li><a href="#"><input type="text" class="st-default-search-input"></a></li> -->
                    </ul>
                </div>
            </div><!--/.container-->
        </nav><!--/nav-->
    </header><!--/header-->
<div class="container-fluid">
    <section id="blog">
        <div class="">
            <section class="content-with-sidebar">
            <div class="row">
                <div class="col-sm-12 ">

                    <div id="mainContent" class="row">
                        <div class="col-sm-12">
                            <div class="blog-post blog-large wow fadeInLeft" data-wow-duration="300ms" data-wow-delay="0ms">
                            <!-- Start of guide -->
                                <div class="service-box wow fadeInRight">
                                    <div class="">

<!--                         <p><h2 id="overview">Overview</h2>

<p>EMDK for Android 7.3 (and later) contains interfaces for controlling hardware that conforms to the Infrared Data Association (IrDA) specification, an infrared line-of-sight technology that's used for data transfer between small portable devices such as mobile computers, printers, handheld remote controls and some medical devices. IrDA also refers to the protocols used for wireless data transfer using IrDA-equipped devices. </p>

<p>Zebra's IrDA implementation supports the following protocols:</p>

<ul>
<li>TinyTP</li>

<li>IrLMP</li>

<li>IrLAP/LSAP</li>

<li>IrSIR</li>

<li>IrDA:RAW</li>
</ul>

<p>Zebra IrDA APIs operate through Android intents – specific commands that can be used by Android applications to control IrDA hardware on IrDA-equipped Zebra devices. This guide explains how to communicate wirelessly between IrDA devices using IrDA Intent APIs on Zebra mobile devices. </p>

<h3 id="requirements">Requirements</h3>

<p>Use of IrDA APIs requires experience with Java and Android app development, and familiarity with Android intents. For successful IrDA communication, <strong>target device(s) must contain</strong>: </p>

<ul>
<li>One or more IrDA-equipped Zebra devices</li>

<li>DataWedge version 7.3.11 or later on the device</li>

<li>IrDA transceivers in clear line of sight during data transmission</li>
</ul>

<hr />

<h2 id="irdaintentapis">IrDA Intent APIs</h2>

<p>IrDA intent APIs can be used in applications that require control of IrDA communication. Supported intent actions and commands are listed below. </p>

<p><strong>IrDA Intents and Actions</strong>:</p>

<ul>
<li><p><code>com.symbol.irda.api.ACTION_DO</code>:</p>

<ul>
<li>Send data
<br>
<br></li></ul></li>

<li><p><code>com.symbol.irda.api.ACTION_GET</code>:</p>

<ul>
<li>Get server name</li>

<li>Get driver version</li>

<li>Get connection idle time</li>

<li>Get configuration
<br>
<br></li></ul></li>

<li><p><code>com.symbol.irda.api.ACTION_REGISTER</code>:</p>

<ul>
<li>Register/Unregister callbacks
<br>
<br></li></ul></li>

<li><p><code>com.symbol.irda.api.ACTION_UPDATE</code>:</p>

<p><ul>
<li>Set server name</li></p>

<p><li>Set connection idle time</li></p>

<p><li>Set configuration
<br></li></ul></p></li>
</ul>

<h5 id="usageinformationforeachcommandfollowsinthesectionsbelow">Usage information for each command follows in the sections below.</h5>

<hr />

<h2 id="senddata">Send Data</h2>

<p>To send data over IrDA, data must be converted to byte arrays. Large data is broken into small chunks of bytes prior to delivery to the receiving device. The first <code>SEND_DATA</code> command typically requires extra time to complete; <code>SEND_DATA</code> commands sent within 30 seconds of the first complete more quickly. The 30-second time frame is adjustable; see <a href="#setconnectionidletime">Set Connection Idle Time</a> section for details.</p>

<h3 id="samplecode">Sample Code</h3>

<h4 id="tosenddataviairda">To send data via IrDA:</h4>

<pre><code>    :::Java
    Intent intent = new Intent(); //Create new intent

    //Specify the IrDA action
    intent.setAction("com.symbol.irda.api.ACTION_DO");

    //Set to run at foreground priority, with a shorter timeout interval 
    intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND); 

    //Text to be sent over IrDA
    String text = "Hello IrDA"; 

    //Convert to byte array to be accepted by SEND_DATA
    byte[] byteArray = text.getBytes();

    //Supported value up to 1024 bytes
    intent.putExtra("SEND_DATA", byteArray); 

    //Designate the broadcast receiver to receive the response
    Intent responseIntent = new Intent(getApplicationContext(), MyBroadcastReceiver.class); 

    //Set to run at foreground priority, with a shorter timeout interval
    responseIntent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);

    //Any extras are useful to identify feedback
    responseIntent.putExtra("COMMAND", "SEND_DATA"); 

    //Create pending intent
    PendingIntent piResponse = PendingIntent.getBroadcast(getApplicationContext().getApplicationContext(), REQUEST_CODE, responseIntent, PendingIntent.FLAG_UPDATE_CURRENT);

    //Send pending intent as CALLBACK_RESPONSE
    //IrDA API responds to the pending intent specified here
    intent.putExtra("CALLBACK_RESPONSE", piResponse); 

    //Send the broadcast
    sendBroadcast(intent); 
</code></pre>

<p>To determine command success, see <a href="#getfeedbackforcommands">Get Feedback for Commands</a>. </p>

<hr />

<h2 id="setservername">Set Server Name</h2>

<p>For IrDA communication, the Zebra device serves as the “client” and the device it communicates with is the “server." To identify the device it communicates with, set the server name of the device. If a server name is not specified, the default “<strong>IrDA:TinyTP</strong>” is used.</p>

<h3 id="samplecode-1">Sample Code</h3>

<p>Set the server name:</p>

<pre><code>    :::Java
    //Create new intent 
    Intent intent = new Intent(); 

    //Specify the IrDA action
    intent.setAction("com.symbol.irda.api.ACTION_UPDATE");

    //Set to run at foreground priority with a shorter timeout interval 
    intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND); 

    //Server name to be used
    intent.putExtra("SERVER_NAME", "&lt;NEW SERVER NAME&gt;"); 

    //Mention the broadcast receiver to receive the response
    Intent responseIntent = new Intent(getApplicationContext(), MyBroadcastReceiver.class); 

    //Set to run at foreground priority with a shorter timeout interval
    responseIntent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);

    //Any extras are useful to identify feedback 
    responseIntent.putExtra("COMMAND", "SET_SERVER_NAME"); 

    //Create pending intent
    PendingIntent piResponse = PendingIntent.getBroadcast(getApplicationContext().getApplicationContext(), REQUEST_CODE, responseIntent, PendingIntent.FLAG_UPDATE_CURRENT);

    //Send pending intent as CALLBACK_RESPONSE
    //IrDA API responds to the pending intent specified here
    intent.putExtra("CALLBACK_RESPONSE", piResponse); 

    //Send the broadcast
    sendBroadcast(intent); 
</code></pre>

<p>The new server name is kept in device memory until device restart, after which the server name is reset to the “<strong>IrDA:TinyTP</strong>” default server name. To determine command success, see <a href="#getfeedbackforcommands">Get Feedback for Commands</a>.</p>

<hr />

<h2 id="registercallbacks">Register Callbacks</h2>

<p>The application must be registered for callbacks to receive messages or responses from the server. Once the callback is processed, the application can act accordingly depending on the response received.</p>

<h3 id="samplecode-2">Sample Code</h3>

<h4 id="registerandreceivecallbacksfromtheserver">Register and receive callbacks from the server:</h4>

<pre><code>    :::Java
    //Create new intent
    Intent intent = new Intent(); 

    //Specify the IrDA action
    intent.setAction("com.symbol.irda.api.ACTION_REGISTER");

    //Set to run at foreground priority, with a shorter timeout interval 
    intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND); 

    //Intent to be sent back with status (via explicit broadcast)
    Intent responseIntent = new Intent(this, MyBroadcastReceiver.class);

    //Cross-check the extras specified here vs the intent received to the broadcast receiver to identify the related response
    responseIntent.putExtra("COMMAND", "REGISTER_CALLBACK_CALL");

    //Set to run at foreground priority, with a shorter timeout interval 
    responseIntent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND); 
    PendingIntent piResponse = PendingIntent.getBroadcast(getApplicationContext(), REQUEST_CODE, responseIntent, PendingIntent.FLAG_UPDATE_CURRENT);

    //Send pending intent as CALLBACK_RESPONSE
    //IrDA API responds to the pending intent specified here
    intent.putExtra("CALLBACK_RESPONSE", piResponse); 

    //Intent called whenever data is received from the server
    int flags2 = 0;
    int requestCode2 = 3;
    Intent dataCallBackIntent = new Intent(this, MyBroadcastReceiver.class);
    dataCallBackIntent.putExtra("COMMAND", "REGISTERED_CALLBACK_DATA");

    //Set to run at foreground priority, with a shorter timeout interval
    dataCallBackIntent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND); 
    PendingIntent piDataCallback = PendingIntent.getBroadcast(getApplicationContext(), requestCode2, dataCallBackIntent, flags2);

    //Send pending intent as DATA_CALLBACK
    //IrDA API responds to the pending intent specified here when a data is received from the server
    intent.putExtra("DATA_CALLBACK", piDataCallback); 

    //Send the broadcast
    sendBroadcast(intent); 
</code></pre>

<p>After executing the code above, callbacks from the server are delivered to the broadcast receiver. </p>

<p>The extras specified for the <code>dataCallBackIntent</code> versus the broadcast receiver intent can be cross-checked to identify the related response as follows:</p>

<h4 id="checkthecommandparameter">Check the COMMAND parameter:</h4>

<pre><code>    :::Java
    public class MyBroadcastReceiver extends BroadcastReceiver {

    @Override
    public void onReceive(Context context, Intent intent) {

        String command = intent.getStringExtra("COMMAND");

        String status = "";
        if(command != null &amp;&amp; command.equalsIgnoreCase("REGISTERED_CALLBACK_DATA")) {
            byte[] data = intent.getByteArrayExtra("DATA_CALLBACK");
            status += " "+ data.length + " bytes received!";
        }
        Log.d("TAG",status);
    }
}
</code></pre>

<p>To receive the response from the server, extract the information from <code>DATA_CALLBACK</code>.</p>

<hr />

<h2 id="unregistercallbacks">Unregister Callbacks</h2>

<p>For each callback that is registered, a corresponding call is needed to unregister the callback. Set the DATA_CALLBACK parameter to NULL to unregister the callback.</p>

<h3 id="samplecode-3">Sample Code</h3>

<h4 id="unregisterthecallback">Unregister the callback:</h4>

<pre><code>    :::Java
    //Create new intent
    Intent intent = new Intent();  

    //Specify the IrDA action
    intent.setAction("com.symbol.irda.api.ACTION_REGISTER");

    //Set to run at foreground priority, with a shorter timeout interval 
    intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND); 

    //Mention the broadcast receiver to receive the response
    Intent responseIntent = new Intent(this, MyBroadcastReceiver.class);

    /Any extras are useful 
    responseIntent.putExtra("COMMAND", "UNREGISTER_CALLBACK_CALL"); /        
</code></pre>

<h4 id="identifythefeedbackatbroadcastreceiver">Identify the feedback at broadcast receiver</h4>

<pre><code>    :::Java
    //Create pending intent
    PendingIntent piResponse = PendingIntent.getBroadcast(getApplicationContext(), REQUEST_CODE, responseIntent, PendingIntent.FLAG_UPDATE_CURRENT);

    //Send pending intent as CALLBACK_RESPONSE
    //IrDA API responds to the pending intent specified here
    intent.putExtra("CALLBACK_RESPONSE", piResponse);

    //Send DATA_CALLBACK as null to stop receiving callbacks from the server
    intent.putExtra("DATA_CALLBACK", (String)null); 

    //Send the broadcast
    sendBroadcast(intent); 
</code></pre>

<hr />

<h2 id="setconnectionidletime">Set Connection Idle Time</h2>

<p>The IrDA port is opened when the first <code>SEND_DATA</code> command is received. The port is kept open for 30 seconds by default. Within this time frame, subsequent <code>SEND_DATA</code> commands are not needed to open the port again. After 30 seconds from the last IrDA API call, the port is closed. This time frame is adjustable by setting the connection idle time.</p>

<h3 id="samplecode-4">Sample Code</h3>

<h4 id="setconnectionidletime-1">Set connection idle time:</h4>

<pre><code>    :::Java
    //Create new intent
    Intent intent = new Intent(); 

    //Specify the IrDA action
    intent.setAction("com.symbol.irda.api.ACTION_UPDATE"); 

    //Set to run at foreground priority, with a shorter timeout interval.
    intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND); 

    //Set idle time to 15 seconds
    intent.putExtra("CONNECTION_IDLE_TIME", 15); 

    //Mention the broadcast receiver to receive the response
    Intent responseIntent = new Intent(getApplicationContext(), MyBroadcastReceiver.class);

    //Set to run at foreground priority, with a shorter timeout interval.
    responseIntent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);  

    //Any extras are useful to identify the feedback at the broadcast receiver
    responseIntent.putExtra("COMMAND", "SET_CONNECTION_IDLE_TIME"); 
    PendingIntent piResponse = PendingIntent.getBroadcast(getApplicationContext().getApplicationContext(), REQUEST_CODE, responseIntent, PendingIntent.FLAG_UPDATE_CURRENT);

    //Send pending intent as CALLBACK_RESPONSE
    //IrDA API responds to the pending intent specified here
    intent.putExtra("CALLBACK_RESPONSE", piResponse); 

    //Send the broadcast
    sendBroadcast(intent); 
</code></pre>

<p>To determine command success, see <a href="#getfeedbackforcommands">Get Feedback for Commands</a>. </p>

<hr />

<h2 id="getcommand">Get Command</h2>

<p>The Get command retrieves the following properties:</p>

<p><code>CONNECTION_IDLE_TIME</code> - Returns the time (in seconds) the connection remains open before automatically closing 
<code>SERVER_NAME</code> - Returns the current server name 
<code>DRIVER_VERSION</code> - Driver version </p>

<h3 id="samplecode-5">Sample Code</h3>

<h4 id="getdriverversion">Get driver version:</h4>

<pre><code>    :::Java
    //Create new intent
    Intent intent = new Intent(); 

    //Specify the IrDA action
    intent.setAction("com.symbol.irda.api.ACTION_GET");

    //Set to run at foreground priority, with a shorter timeout interval 
    intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND); 

    //Mention the properties to Retrieve
    String[] propertiesToRetrieve = {"DRIVER_VERSION", "CONNECTION_IDLE_TIME", "SERVER_NAME"};

    //Assign the properties to retrieve to PROPERTIES_TO_GET extra
    intent.putExtra("PROPERTIES_TO_GET", propertiesToRetrieve);  

    //Mention the broadcast receiver to receive the response
    Intent responseIntent = new Intent(getApplicationContext(), MyBroadcastReceiver.class);

    //Set to run at foreground priority, with a shorter timeout interval
    responseIntent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND); 

    //Any extras are useful to identify the feedback at the broadcast receiver 
    responseIntent.putExtra("COMMAND", "GET_DRIVER_VERSION"); 

    //Create pending intent
    PendingIntent piResponse = PendingIntent.getBroadcast(getApplicationContext().getApplicationContext(), REQUEST_CODE, responseIntent, PendingIntent.FLAG_UPDATE_CURRENT);

    //Send pending intent as CALLBACK_RESPONSE
    //IrDA API responds to the pending intent specified here.
    intent.putExtra("CALLBACK_RESPONSE", piResponse);

    //Send the broadcast 
    sendBroadcast(intent); 
</code></pre>

<h4 id="decodethegetcommandresponse">Decode the Get command response</h4>

<p>The Get command response is delivered to the broadcast receiver in the pending intent to retrieve the queried data.</p>

<h4 id="retrievedatafromthegetcommand">Retrieve data from the Get command:</h4>

<pre><code>    :::Java
    public class MyBroadcastReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {

        String status = "";
        String command = intent.getStringExtra("COMMAND");
        if(command != null) {
            switch (command) {
                case "GET_SERVER_NAME":
                    status += " "+ intent.getStringExtra("SERVER_NAME");
                    break;
                case "GET_CONNECTION_IDLE_TIME":
                    status += " "+ intent.getIntExtra("CONNECTION_IDLE_TIME",0);
                    break;
                case "GET_DRIVER_VERSION":
                    status += " "+ intent.getStringExtra("DRIVER_VERSION");
                    break;

            }
        }
        Log.d("TAG",status);
    }
}
</code></pre>

<hr />

<h2 id="getfeedbackforcommands">Get Feedback for Commands</h2>

<p>The <code>ACTION_DO</code> and <code>ACTION_UPDATE</code> methods send a <code>RESULT_CODE</code> and a <code>RESULT_MESSAGE</code> back to the client app with feedback about whether the specified command succeeded. This response is delivered to the broadcast receiver and passed to the pending intent.</p>

<h3 id="samplecode-6">Sample Code</h3>

<h4 id="getfeedbackfromcommands">Get feedback from commands:</h4>

<pre><code>    :::Java
    public class MyBroadcastReceiver extends BroadcastReceiver {

    @Override
    public void onReceive(Context context, Intent intent) {

        String status = "";
        String command = intent.getStringExtra("COMMAND");
        String resultCode = intent.getStringExtra("RESULT_CODE");
        String resultMessage = intent.getStringExtra("RESULT_MESSAGE");

        if(command != null)
            status += "" + command + ": ";

        if(resultCode != null)
            status += "" + resultCode;

        if(resultMessage != null)
            status += "\nMessage: " + resultMessage;

        Log.d("TAG",status);

    }
}
</code></pre>

<hr />

<h2 id="setgetconfigurations">Set/Get Configurations</h2>

<p>Used to set the configuration of the IrDA port. <strong>Only the IrDA:RAW protocol supports setting configurations</strong> at this time. Use the intent extra <code>CONFIG</code> to set the baud rate. The parameter key, data type and supported values are shown below.</p>

<ul>
<li><strong>Key</strong>: BAUD_RATES</li>

<li><strong>Data Type</strong>: String</li>

<li><strong>Supported values</strong>: 1200, 2400, 9600, 19200, 38400, 57600, 115200</li>
</ul>

<p><code>SET_CONFIGURATION_FAILED</code> - returned if an error occurrs while setting a configuration. <strong>Note</strong>: Unsupported values are ignored (no error is returned).</p>

<h3 id="samplecode-7">Sample Code</h3>

<h4 id="setconfiguration">Set configuration:</h4>

<pre><code>    :::java
    Intent intent = new Intent();
    intent.setAction("com.symbol.irda.api.ACTION_UPDATE");

    Bundle bundle = new Bundle();
    bundle.putString("BAUD_RATES","2400");
    intent.putExtra("CONFIG", bundle);

    Intent responseIntent = new Intent(getApplicationContext(), MyBroadcastReceiver.class);
    responseIntent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
    responseIntent.putExtra("COMMAND", "SET_CONFIG");
    PendingIntent piResponse = PendingIntent.getBroadcast(getApplicationContext().getApplicationContext(), REQUEST_CODE, responseIntent, PendingIntent.FLAG_UPDATE_CURRENT);
    intent.putExtra("CALLBACK_RESPONSE", piResponse);
    sendBroadcast(intent);
</code></pre>

<h4 id="getconfiguration">Get configuration:</h4>

<pre><code>    :::java
    Intent intent = new Intent();
    intent.setAction("com.symbol.irda.api.ACTION_GET");
    String[] propertiesToRetrieve = {"CONFIG"};
    intent.putExtra("PROPERTIES_TO_GET", propertiesToRetrieve);

    Intent responseIntent = new Intent(getApplicationContext(), MyBroadcastReceiver.class);
    responseIntent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
    responseIntent.putExtra("COMMAND", "GET_CONFIGURATIONS");
    PendingIntent piResponse = PendingIntent.getBroadcast(getApplicationContext().getApplicationContext(), REQUEST_CODE, responseIntent, PendingIntent.FLAG_UPDATE_CURRENT);
    intent.putExtra("CALLBACK_RESPONSE", piResponse);
    sendBroadcast(intent);
</code></pre>

<h4 id="getconfigurationbroadcastreceiver">Get configuration broadcast receiver:</h4>

<pre><code>:::java
public class IrDABroadcastReceiver extends BroadcastReceiver {

@Override
public void onReceive(Context context, Intent intent) {
    String config = "";
    if(intent.hasExtra("CONFIG")) {
        Bundle bundleConfig = intent.getExtras().getBundle("CONFIG");
        if(bundleConfig != null) {
            for (String key : bundleConfig.keySet()) {
                config += "\n" + key + ": " + bundleConfig.getString(key);
                }
            }
        }
    }
}
</code></pre>

<hr />

<h2 id="alsosee">Also See</h2>

<ul>
<li><a href="../datacapture">Data capture intent APIs</a></li>

<li><a href="../battery">Battery intent APIs</a></li>

<li><a href="../../api">Native APIs</a></li>
</ul></p>
 -->                        

<h2 id="redirecting-to-techdocs-archive-site" class="anchor"><a class="heading-anchor" href="#redirecting-to-techdocs-archive-site"><span></span></a>Redirecting to TechDocs archive site...</h2> 


                                    </div>
                                </div>

                            </div>
                        </div>
                    </div>
                </div><!--/.col-sm-6-->
            </div>
            </section>
        </div>
    </section>    


<div class="modal fade" id="basicModal" tabindex="-1" role="dialog" aria-labelledby="basicModal" aria-hidden="true" data-backdrop="true">
			<div class="modal-dialog">
				<div class="modal-content">
					<div class="modal-header">
						<button type="button" class="close" data-dismiss="modal" aria-hidden="true">X</button>
					</div>
					<div class="modal-body">
						<div id="modalImg">
						
						</div>
					</div>
			</div>
		  </div>
		</div>
    <script>

    var new_domain = "zebra-techdocs-archive.netlify.app";
    var old_domain = window.location.host;
    var current_href = window.location.href;
    var new_href = current_href.replace(old_domain,new_domain);
    window.location = new_href;

    </script>
                                        
</div></body></html>